# Maps and Sets
A new kind of collections

--

You already have `arrays` and `objects` and you can use them as collections.

--

Still, arrays are pretty simple and objects are an overkill for such simple job. 

--

With ES6 you now have access to new special objects that are filling this gap: 

**Map and Set** with their variations **WeakMap and WeakSet**

---
## Map

So what the Map object does exactly?

--

> It holds **key-value pairs** and remembers the original insertion order of the keys. 

--

> Any value (both objects and primitive values) may be used as either a key or a value.

--

Let's go through the main differences between collecting data with an object vs with a map

--

| Object                                    | Map                                                            |
|-------------------------------------------|----------------------------------------------------------------|
| unordered keys                            | ordered keys                                                   |
| keys can be string or symbols             | keys can be anything (other objects, primitives, functions...) |
| iterate require you to get the keys first | it is an iterable so you can loop straight away                |

--

The main methods of the Map object are

--
<pre>
new Map()            -> creates the map.                                                    
map.set(key, value)  -> stores the value by the key                                         
map.get(key)         -> returns the value by the key, undefined if no key 
map.has(key)         -> returns true if the key exists, false otherwise                     
map.delete(key)      -> removes the value by the key                                        
map.clear()          -> clears the map                                                      
map.size             -> returns the current element count.                                  
</pre>
--
A basic example could look like:

``` js
let map = new Map();

map.set('1', 'my key is a string'); // a string key
map.set(1, 'my key is a number'); // a numeric key
map.set(true, 'my key is a boolean'); // a boolean key

// remember the regular Object? it would convert keys to string
// Map keeps the type, so these two are different:
console.log(map.get(1)); //'my key is a number'
console.log(map.get('1')); //'my key is a string'
console.log(map.get(true)); //'my key is a boolean'

console.log(map.size); // 3
```
--

Let's compare a bit more Map and a normal object

--

Objects can be created in various ways
``` js
let obj = {}; // literal
let obj = new Object(); // via constructor
let obj = new Object; // same
let obj = Object.create(); // via prototype
```

Maps can only be created by calling `new`
``` js
let map = new Map(); //Empty Map
```
--
Object values can be accessed in two ways:
``` js
obj.id
obj['id']

```
Map has only one way to access the element:
``` js
map.get(id)
```
--
In Object when you search for a key, you do something like:
``` js
const idIsThere = obj.id !== undefined;
// or better
const idIsThere = 'id' in obj;
```
Map can easily check if a key is there:
``` js
map.has(id); //return a boolean
```
--
Adding a new element to an object looks like
``` js
obj['name'] = 'Max';
obj.name = 'Max'; 
```

while in map you can pass key and value as parameters
``` js
map.set(name, 'Max');
```
--
The object way of deleting the pair property value
``` js
delete obj.id; 
```
while maps does it, consistently, with an explicit method
``` js
map.delete(id)
// you even have one method to flush the entire map:
map.clear();
```
--
Getting the size from an object is ugly and you have to do it every time you need
``` js
console.log(Object.keys(obj).length);
```
while the map maintain a property for that purpose
``` js
console.log(map.size);
```
--
Iterating in a object is like:
``` js
// using for… in
for (let key in obj){
   console.log(`key: ${key}, value: ${obj[key]}`);
}
// or Object.keys
Object.keys(obj).forEach((key)=> console.log(`key: ${key}, value: ${obj[key]}`));
```
with map is easier because is **built-in iterable**
``` js
// using the for… of
for (const item of map){
    console.log(item); 
}
// Or
for (const [key,value] of map){
    console.log(`key: ${key}, value: ${value}`);
}
```
--

Wait a min..
 
![the old days](https://media.giphy.com/media/Z9jqlziozpC00/giphy.gif)
 
 you know the difference between `for in` and `for of`, right?


--
Just in case ;-)

> for... in

loops over enumerable **property names** of an object.

> for... of (new in ES6)

use an **object-specific iterator** and loops over the **values** generated by that.

--

And now some examples

--
### Using an object as a key

``` js
let john = { name: "John" };

// for every user, let's store their visits count
let visitsCountMap = new Map();

// john is the key for the map
visitsCountMap.set(john, 123);

alert( visitsCountMap.get(john) ); // 123

```
--

### Chaining 

Every map.set call returns the map itself, so we can “chain” the calls:
``` js
map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');
```
--
### Passing [key, value] pairs in the constructor
``` js
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);
```
--
### A map from an object
``` js
let map = new Map(Object.entries({
  name: "John",
  age: 30
}));
// Object.entries returns the array of key/value pairs
```
--

## Iterating over Map

You have 3 methods that helps you with that:

<pre>
map.keys()    – returns an iterable for keys,
map.values()  – returns an iterable for values,
map.entries() – returns an iterable for entries [key, value], 
                it’s used by default in for..of.
</pre>
--

I know, I keep talking about iterable without explaining what is it.

Hold it for now, we will talk about that when it comes to Symbol

--
Let's consider this Map
``` js
let recipeMap = new Map([
  ['spaghetti', '500g'],
  ['bacon', '150g'],
  ['eggs',    5],
  ['pecorino', '40g']
]);
```
--
and see how can we iterate trough

``` js
// iterate over keys
for (let ingredients of recipeMap.keys()) {
  console.log(ingredients); // spaghetti, bacon, eggs, pecorino
}

// iterate over values
for (let quantity of recipeMap.values()) {
  console.log(quantity); // 500g, 150g, 5, 40g
}

// iterate over [key, value] entries
for (let entry of recipeMap) { // the same as of recipeMap.entries()
  console.log(entry); // spaghetti,500g (and so on)
}
```
--
and you can also do it with a build in forEach
``` js
recipeMap.forEach( (value, key, map) => {
  console.log(`${key}: ${value}`); // spaghetti: 500g etc
});
```
--

We covered a lot, let's wrap up then
![the old days](https://media.giphy.com/media/nQdIeEMDNtASk/giphy.gif)
--

By now I think you see how straight forward Map is

--

So you might wondering if you should always use Map instead of an object when it comes to collection.


--

Well... not so fast. 

![the old days](https://media.giphy.com/media/ceeN6U57leAhi/giphy.gif)

--

If you have to deal with a **simple structure** and you already know that the keys will be either strings, numbers or symbols...

**you should still stick to a regular object!**

--

Why?

Because creating plain objects and accessing their property with a specific key is way faster than instantiating a Map.

Once you create a Map, you are calling a constructor and then using the abstraction provided by his method; on the other case you are dealing with a literal on a lower level.

--

Regular object are also the only way to go if you have to use logic on a property (a function for example)

``` js
const obj = {
    id: 1, 
    name: "It's Me, Mario!", 
    print: function(){ 
        return `Object Id: ${this.id}, with Name: ${this.name}`;
    }
}
```
--

You can definitely use Map when:
* your keys are complex (like entire objects)
* you really need to keep the order of the elements
* you have a lot of insert and delete routines
* you are dealing with a large set of data, specially when keys and values are of the same type

--

Anyway, this is just a suggestion. 

One could argue that, in general, you should use Map every time you need an "associative array". 

![jjust dont](https://media.giphy.com/media/jP6d3UZh8GNRm/giphy.gif)


--

## Exercise

We want to know who is faster between an object and a Map when it comes to certain situation.
 
Let's create a little "benchmark test" then!

--
> Bonus:  use pair programming!

![pair programming](https://media.giphy.com/media/11p1apCPqM7WEw/giphy.gif)

--

Meaning you do it together with another colleague. 
Rules are:
* one person drive (so write the code)
* the other navigate (explain what to do without diving too much in details)

--

you can exchange roles but do not mix! 

Navigator should be able to talk clean javascript and not saying stuff like "copy this here, move that at the end, you fuck up the loop, let me do it instead" 

--
Have fun:
* Perpare a simple object with at least 3 properties.
* Then programmatically create and immediately delete one entry at the time and always output the size; do it for a number of times (let say min 10000).
* Do the same with a Map. 
* Now compare the execution time. 

---

# Set

--

Set is a collection which only holds **values only**, no key pair here

--

You could say that we already have the `array` for that...

--

True, but Set is different because hold **unique values only**!

--

That means, no value can appear more often than once in a Set

--

You can loop through a set to retrieve the values (or use an Iterator)

You can also clear() a set or delete individual values by using delete(). 

--

Because each value is unique, you don’t need a key or index to delete a value!

--

Besides those specifics, the rest is pretty much similar to Map

``` js
let cardAce = {
 name: 'Ace of Spades'
};
let cardKing = {
 name: 'King of Clubs'
};
let deck = new Set();
deck.add(cardAce);
deck.add(cardKing);
deck.add(cardKing); // Won’t be added, only added once!
```
--

## WeakMap and WeakSet

> WeakSet is a special kind of Set that does not prevent JavaScript from removing its items from memory. WeakMap is the same thing for Map.

--

The practical effects are that you can't iterate and you don't have the size property.

Oh, and of course, you can only use reference types in the key (for Map) or as value (Set)

--

Why that?

Because stored values are kept in the Map/Set trough **weak** references, so they will released when those objects will not be used anywhere else.

--

The reason is all about performances: if you use Map or Set, the referenced object will not be garbage collected even if they were not used anywhere else.

---
## Recap!

![the old days](https://media.giphy.com/media/SJAt3WDv9t5yE/giphy.gif)

--

Map and Set are part of the so called

> Keyed collections

--

They were introduced in ES6 

-- 

Their purpose is to free the object from the standard collection functionality

--

They do it by providing a standardized way to access iterables

```js
new Map([iterable])
```
--

They are able to hold complex keys and bring performance advantages


 
